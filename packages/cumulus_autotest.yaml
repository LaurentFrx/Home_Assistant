################################################################################
# Package : Cumulus – Auto-test
# Fichier : packages/cumulus_autotest.yaml
# Objet   : lancer un auto-test "dry-run" (aucune action sur le contacteur)
#           et publier le résultat :
#           - input_text.cumulus_test_status  : idle|running|pass|fail
#           - input_text.cumulus_test_report  : résumé ≤255 caractères
#           - Notification persistante : rapport détaillé
################################################################################

############################
# HELPERS (affichage UI)
############################
input_text:
  cumulus_test_status:
    name: "Cumulus — Auto-test statut"
    initial: "idle"
    max: 32
    mode: text

  cumulus_test_report:
    name: "Cumulus — Rapport auto-test (résumé)"
    initial: ""
    max: 255
    mode: text

############################
# SCRIPT : lancer l’auto-test
############################
script:
  cumulus_autotest_run:
    alias: "Cumulus | Auto-test (dry-run)"
    mode: restart
    sequence:

      # 0) Marquer le début
      - service: input_text.set_value
        target: { entity_id: input_text.cumulus_test_status }
        data:   { value: "running" }
      - service: input_text.set_value
        target: { entity_id: input_text.cumulus_test_report }
        data:   { value: "" }

      # 1) Charger les paramètres et états (lecture seule)
      - variables:
          # Réglages issus de cumulus.yaml
          p_nom: "{{ states('input_number.cumulus_puissance_nominale_w')|int(2950) }}"
          talon: "{{ states('input_number.cumulus_talon_reseau_w')|int(300) }}"
          marge_imp: "{{ states('input_number.cumulus_marge_import_w')|int(120) }}"
          marge_surplus: "{{ states('input_number.cumulus_marge_surplus_w')|int(150) }}"
          soc_start: "{{ states('input_number.cumulus_soc_start_pct')|int(25) }}"
          soc_stop:  "{{ states('input_number.cumulus_soc_stop_pct')|int(15) }}"
          deadband_s: "{{ states('input_number.cumulus_deadband_s')|int(100) }}"
          tempo_on_s: "{{ states('input_number.cumulus_on_delay_day_s')|int(20) }}"

          # Capteurs "live"
          imp_live: >-
            {% set v = states('sensor.cumulus_import_estime_w') %}
            {{ v|float(0) if v not in ['unknown','unavailable',''] else 0.0 }}
          surplus_live: >-
            {% set v = states('sensor.cumulus_surplus_estime_w') %}
            {{ v|float(0) if v not in ['unknown','unavailable',''] else 0.0 }}

          pv_live: "{{ is_state('binary_sensor.cumulus_en_fenetre_pv','on') }}"
          hc_live: "{{ is_state('binary_sensor.cumulus_en_heures_creuses','on') }}"
          pv_auth_live: "{{ is_state('binary_sensor.cumulus_pv_ok_simple','on') }}"
          relais_on_live: "{{ is_state('switch.shellypro1_ece334ee1b64','on') }}"
          db_actif_live: "{{ is_state('timer.cumulus_deadband','active') }}"
          nd_actif_live: "{{ is_state('timer.cumulus_no_delay','active') }}"
          soc_live: >-
            {% set v = states('input_number.cumulus_soc_cache_pct') %}
            {{ v|int(0) if v not in ['unknown','unavailable',''] else 0 }}

          # Hypothèse matériel : puissance max Solarbank vers la maison
          sb_max: 1200

          # Seuils dérivés
          imp_tolere: "{{ talon + marge_imp }}"
          besoin_start: >-
            {% set b = p_nom - sb_max - talon - marge_surplus %}
            {{ 0 if b < 0 else b }}

      # 2) Scénarios simulés (aucune écriture d’état)
      # A. Démarrage jour : gardes OK, SOC ≥ start, SB=1200W
      - variables:
          A_expected_ok: true
          A_surplus_simu: "{{ besoin_start }}"
          A_calc_ok: "{{ A_surplus_simu|int(0) >= besoin_start|int(0) }}"
          A_pass: "{{ A_expected_ok == (A_calc_ok | bool) }}"

      # B. Limiteur import : import simulé > seuil → coupure attendue
      - variables:
          B_imp_simu: "{{ imp_tolere|int(0) + 100 }}"
          B_expected_cut: true
          B_calc_cut: "{{ B_imp_simu|int(0) > imp_tolere|int(0) }}"
          B_pass: "{{ B_expected_cut == (B_calc_cut | bool) }}"

      # C. Sécurité batterie : SOC < seuil stop → coupure
      - variables:
          C_soc_simu: "{{ soc_stop|int(15) - 1 }}"
          C_expected_cut: true
          C_calc_cut: "{{ C_soc_simu|int(0) < soc_stop|int(15) }}"
          C_pass: "{{ C_expected_cut == (C_calc_cut | bool) }}"

      # D. Fenêtre "no-delay" : tempo ON=0 s & deadband suivant=15 s
      - variables:
          D_expected_tempo_on: 0
          D_expected_db_suivant: 15
          D_calc_tempo_on: 0
          D_calc_db_suivant: 15
          D_pass: "{{ (D_expected_tempo_on == D_calc_tempo_on) and (D_expected_db_suivant == D_calc_db_suivant) }}"

      # E. Entrée HC : rattrapage autorisé seulement si journée non terminée
      - variables:
          E_temp_fini: "{{ is_state('input_boolean.cumulus_temp_atteinte_aujourdhui','on') }}"
          E_expected_ok: "{{ not (E_temp_fini | bool) }}"
          E_calc_ok: "{{ not (E_temp_fini | bool) }}"
          E_pass: "{{ (E_expected_ok | bool) == (E_calc_ok | bool) }}"

      # 3) Agrégat & rapport
      - variables:
          all_pass: "{{ (A_pass | bool) and (B_pass | bool) and (C_pass | bool) and (D_pass | bool) and (E_pass | bool) }}"
          ok: "✅"
          ko: "❌"

          live_line: >-
            Live: PV={{ 'ON' if pv_live else 'OFF' }} · HC={{ 'ON' if hc_live else 'OFF' }}
            · Autorisation PV={{ 'ON' if pv_auth_live else 'OFF' }}
            · Import={{ '%0.1f'|format(imp_live|float(0)) }}W (seuil {{ imp_tolere }}W)
            · Relais={{ 'ON' if relais_on_live else 'OFF' }}
            · DB={{ 'actif' if db_actif_live else 'inactif' }}
            · ND={{ 'actif' if nd_actif_live else 'inactif' }}
            · SOC={{ soc_live }}%.

          header: >-
            [Auto-test] {{ (ok ~ ' PASS') if all_pass else (ko ~ ' FAIL') }}
            — {{ now().strftime('%Y-%m-%d %H:%M:%S') }}
            • A Démarrage jour: {{ ok if A_pass else ko }}
            • B Limiteur import: {{ ok if B_pass else ko }}
            • C Sécurité SOC: {{ ok if C_pass else ko }}
            • D No-delay: {{ ok if D_pass else ko }}
            • E HC: {{ ok if E_pass else ko }}

          params_line: >-
            Paramètres: P_nom={{ p_nom }}W · SOC start={{ soc_start }}%
            · SOC stop={{ soc_stop }}% · Import toléré≈{{ imp_tolere }}W
            (talon {{ talon }} + marge {{ marge_imp }})
            · Besoin démarrage≈{{ besoin_start }}W.

          block_A: >-
            A Démarrage jour (simulé): gardes OK, SOC ≥ {{ soc_start }}%, SB={{ sb_max }}W.
            Attendu: autorisé → {{ ok if A_pass else ko }}.

          block_B: >-
            B Limiteur: import simulé > {{ imp_tolere }}W → coupure auto → {{ ok if B_pass else ko }}.

          block_C: >-
            C Sécurité batterie: SOC simulé < {{ soc_stop }}% → coupure → {{ ok if C_pass else ko }}.

          block_D: >-
            D No-delay: tempo ON={{ D_calc_tempo_on }}s, deadband suivant={{ D_calc_db_suivant }}s → {{ ok if D_pass else ko }}.

          block_E: >-
            E Entrée HC: Rattrapage {{ 'autorisé' if E_expected_ok else 'interdit' }} → {{ ok if E_pass else ko }}.

          rep: >-
            {{ header }}
            {{ params_line }}
            {{ block_A }}
            {{ block_B }}
            {{ block_C }}
            {{ block_D }}
            {{ block_E }}
            {{ live_line }}

          # Résumé Lovelace ≤255 caractères
          rep_short: >-
            {% set s = rep | regex_replace('\s+', ' ') %}
            {{ s[:245] ~ ('…' if s|length > 245 else '') }}

      # 4) Écrire statut + résumé pour Lovelace
      - service: input_text.set_value
        target: { entity_id: input_text.cumulus_test_status }
        data:
          value: "{{ 'pass' if all_pass else 'fail' }}"

      - service: input_text.set_value
        target: { entity_id: input_text.cumulus_test_report }
        data:
          value: "{{ rep_short }}"

      # 5) Notification persistante avec le rapport complet
      - service: persistent_notification.create
        data:
          title: "Cumulus — Auto-test terminé"
          message: "{{ rep }}"
          notification_id: "cumulus_autotest"

################################################################################
# Automatisations autour de l’auto-test (optionnelles)
################################################################################
automation:

  # Lancer l’auto-test chaque jour à 13:30
  - id: cumulus_autotest_daily_run
    alias: "Cumulus | Auto-test quotidien (13:30)"
    mode: single
    trigger:
      - platform: time
        at: "13:30:00"
    action:
      - service: script.cumulus_autotest_run

  # Alerte uniquement si l’auto-test échoue
  - id: cumulus_autotest_alert_on_fail
    alias: "Cumulus | Alerte si auto-test = FAIL"
    mode: restart
    trigger:
      - platform: state
        entity_id: input_text.cumulus_test_status
        to: "fail"
    action:
      - service: persistent_notification.create
        data:
          title: "Cumulus — Auto-test: ÉCHEC"
          message: >-
            {{ states('input_text.cumulus_test_report') }}
            (ouvre les Notifications pour le rapport détaillé).
          notification_id: "cumulus_autotest_fail_only"
          

################################################################################
# FIN
################################################################################